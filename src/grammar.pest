// TODO: don't parse primitive types, true, false, ... as strings, define rules for them instead

num = @{ int ~ ("." ~ ASCII_DIGIT*)? ~ (^"e" ~ int)? }
int = { ("+" | "-")? ~ ASCII_DIGIT+ }

boolean = @{ "true" | "false" }
ident = @{ ALPHABETIC ~ (ALPHABETIC | ASCII_DIGIT )* }

string = ${ "\"" ~
    (string_part | ("\\" ~ escape_c))*
~ "\"" }
    string_part = @{ ( !("\"" | "\\" | NEWLINE) ~ ANY )+ }
    escape_c = @{ ("x" ~ ('0' .. '7') ~ HEX_DIGIT ) | ANY }

type = {
    primitive |
    opt | ptr | slice | array | arrptr |
    grouped
}
    primitive = {
        "bool" | "byte" | "u8" | "i8" | "u16" |
        "i16" | "u32" | "i32" | "float" | "()"
    }
    opt = { "?" ~ type }
    ptr = { "*" ~ type }
    slice = { "[]" ~ type }
    array = { "[" ~ int ~ "]" ~ type }
    arrptr = { "[" ~ "*" ~ "]" ~ type }
    grouped = _{ "(" ~ type ~ ")" }

type_annotation = { (":" ~ type)? }
return_type = { type? }
typed_ident = _{ ident ~ ":" ~ type }

operation = _{
    concat | add | subtract | multiply | divide |
    eq | neq | lt | lte | gt | gte | cast_as
}
    add      = { "+" }
    concat   = { "++" }
    subtract = { "-" }
    multiply = { "*" }
    divide   = { "/" }
    eq       = { "==" }
    neq      = { "!=" }
    lt       = { "<" }
    lte      = { "<=" }
    gt       = { ">" }
    gte      = { ">=" }
    cast_as  = { "as" }

unop = _{ neg | not | ref | deref }
    not   = { "!" }
    ref   = { "&" }
    neg   = { "-" }
    deref = { "*" }

if = {
    "if" ~ expr ~ ":" ~ expr ~ "else" ~ expr
}

typed_idents = { (typed_ident ~ ("," ~ typed_ident)*)? ~ ","? }
idents = { (ident ~ ("," ~ ident)*)? ~ ","? }
exprs = { (expr ~ ("," ~ expr)*)? ~ ","? }

lambda = {
    "fn" ~ "(" ~ idents ~ ")" ~ expr
}
call = {
    ident ~ "(" ~ exprs ~ ")"
}

literal = { num | boolean | string }
expr = { term ~ (operation ~ term)*}
term = _{ if | lambda | literal | call | ident | unop ~ expr | "(" ~ expr ~ ")" | block }

binding = _{
    let_decl | fn_decl | var_decl | rebind
}
    let_decl = { "let" ~ ident ~ type_annotation ~ "=" ~ expr }
    fn_decl = {
        "fn" ~ ident ~ "(" ~ typed_idents ~ ")" ~ return_type
        ~ block
    }
    var_decl = { "var" ~ ident ~ type_annotation ~ "=" ~ expr }
    rebind = { ident ~ "=" ~ expr }
return = { "ret" ~ expr }
    
statement = { (binding | return | expr)? }
    stmnts = { (statement ~ (";" ~ statement)*)? }

block = _{ "{" ~ stmnts ~ "}" }

program = _{ SOI ~
    stmnts
~ EOI }

WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ "//" ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | &EOI) }
