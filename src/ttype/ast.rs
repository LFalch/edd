use crate::rt::{RuntimeError, SymbolTable, Value, Variable};

use std::{cell::RefCell, cmp::Ordering, ops::Neg, rc::Rc};

use super::Type;

mod impls;

#[derive(Debug, Clone, PartialEq)]
pub enum Statement {
    Express(Rc<Type>, Expr),
    Let(Rc<str>, Rc<Type>, Expr),
    Var(Rc<str>, Rc<Type>, Expr),
    Rebind(Rc<str>, Expr),

    Return(Expr),
}

#[derive(Debug, Clone, PartialEq)]
pub enum Expr {
    Ident(Rc<str>),
    ConstBoolean(bool),
    ConstI8(i8),
    ConstU8(u8),
    ConstI16(i16),
    ConstU16(u16),
    ConstI32(i32),
    ConstU32(u32),
    ConstFloat(f64),
    ConstCompInteger(i128),
    ConstUnit,
    ConstString(Rc<str>),
    ConstNull,

    Ref(Box<Self>),
    Array(Box<[Self]>),
    StructConstructor(Box<[(Option<Box<str>>, Expr)]>),
    /// first type is the original type, the second is the target
    Cast(Box<Self>, Rc<Type>, Rc<Type>),

    Add(Box<Self>, Box<Self>),
    Sub(Box<Self>, Box<Self>),
    Mul(Box<Self>, Box<Self>),
    Div(Box<Self>, Box<Self>),
    Concat(Box<Self>, Box<Self>),

    Not(Box<Self>),
    Neg(Box<Self>),
    Deref(Box<Self>),

    Block(Box<[Statement]>),
    Lambda(Box<[(Rc<str>, Rc<Type>)]>, Box<Self>),
    Call(Rc<str>, Box<[Self]>),

    If(Box<Self>, Box<Self>, Box<Self>),
    Eq(Box<Self>, Box<Self>, Rc<Type>),
    Neq(Box<Self>, Box<Self>, Rc<Type>),
    Lt(Box<Self>, Box<Self>, Rc<Type>),
    Lte(Box<Self>, Box<Self>, Rc<Type>),
    Gt(Box<Self>, Box<Self>, Rc<Type>),
    Gte(Box<Self>, Box<Self>, Rc<Type>),

    /// Generated by `eval_const`
    Raise(Box<RuntimeError>),
    /// Generated by `eval_const`
    Var(Rc<RefCell<Value>>),
}

fn try_binop<F, F2>(a: Expr, b: Expr, binop: F, fallback: F2) -> Expr
where
    F: FnOnce(Value, Value) -> Result<Value, RuntimeError>,
    F2: FnOnce(Box<Expr>, Box<Expr>) -> Expr,
{
    match (a.as_value(), b.as_value()) {
        (Some(a), Some(b)) => binop(a, b).map(Expr::from).unwrap_or_else(Expr::from),
        (_, _) => fallback(Box::new(a), Box::new(b)),
    }
}

const MAX_RECUR: i32 = 100;

impl Expr {
    pub fn eval_const(mut self, st: &SymbolTable, args: &[(Rc<str>, Rc<Type>)]) -> Self {
        let mut last = self.clone();
        for _ in 0..MAX_RECUR {
            self = self.eval_const_inner(st, args);
            if last == self {
                break;
            }
            last = self.clone();
        }
        self
    }
    fn eval_const_inner(self, st: &SymbolTable, args: &[(Rc<str>, Rc<Type>)]) -> Self {
        match self {
            Expr::Ident(i) => {
                if i.starts_with('$') {
                    return Expr::Ident(i);
                }
                if let Some(i) = args.iter().position(|(n, _t)| *i == **n) {
                    return Expr::Ident(format!("${i}").into());
                }

                match st.lookup_raw(&i).unwrap() {
                    Variable::Const(v) => v.into(),
                    Variable::Mutable(var) => Expr::Var(var),
                }
            }
            Expr::Var(_)
            | Expr::Raise(_)
            | Expr::ConstBoolean(_)
            | Expr::ConstI8(_)
            | Expr::ConstU8(_)
            | Expr::ConstI16(_)
            | Expr::ConstU16(_)
            | Expr::ConstI32(_)
            | Expr::ConstU32(_)
            | Expr::ConstFloat(_)
            | Expr::ConstCompInteger(_)
            | Expr::ConstUnit
            | Expr::ConstString(_)
            | Expr::ConstNull => self,
            Expr::Add(a, b) => {
                let a = a.eval_const_inner(st, args);
                let b = b.eval_const_inner(st, args);

                if a.is_const_zero() {
                    b
                } else if b.is_const_zero() {
                    a
                } else {
                    try_binop(a, b, |a, b| a + b, Expr::Add)
                }
            }
            Expr::Sub(a, b) => {
                let a = a.eval_const_inner(st, args);
                let b = b.eval_const_inner(st, args);

                if b.is_const_zero() {
                    a
                } else {
                    try_binop(a, b, |a, b| a - b, Expr::Sub)
                }
            }
            Expr::Mul(a, b) => {
                let a = a.eval_const_inner(st, args);
                let b = b.eval_const_inner(st, args);

                if a.is_const_zero() {
                    a
                } else if b.is_const_zero() {
                    b
                } else if a.is_const_one() {
                    a
                } else if b.is_const_one() {
                    b
                } else {
                    try_binop(a, b, |a, b| a * b, Expr::Mul)
                }
            }
            Expr::Div(a, b) => {
                let a = a.eval_const_inner(st, args);
                let b = b.eval_const_inner(st, args);

                if b.is_const_zero() {
                    Expr::Raise(Box::new(RuntimeError::DivideByZero))
                } else if b.is_const_one() {
                    a
                } else {
                    try_binop(a, b, |a, b| a / b, Expr::Div)
                }
            }
            Expr::Concat(a, b) => {
                let a = a.eval_const_inner(st, args);
                let b = b.eval_const_inner(st, args);

                match (a, b) {
                    (Expr::ConstString(a), Expr::ConstString(b)) => {
                        Expr::ConstString(format!("{a}{b}").into())
                    }
                    (a, b) => Expr::Concat(Box::new(a), Box::new(b)),
                }
            }

            Expr::Lambda(_f, _args) => todo!(),
            Expr::Call(_f, _args) => todo!(),

            Expr::If(cond, if_true, if_false) => {
                let cond = cond.eval_const_inner(st, args);

                match cond {
                    Expr::ConstBoolean(true) => if_true.eval_const_inner(st, args),
                    Expr::ConstBoolean(false) => if_false.eval_const_inner(st, args),
                    c => Expr::If(
                        Box::new(c),
                        Box::new(if_true.eval_const_inner(st, args)),
                        Box::new(if_false.eval_const_inner(st, args)),
                    ),
                }
            }
            Expr::Not(rhs) => {
                let rhs = rhs.eval_const_inner(st, args);
                match rhs {
                    Expr::ConstBoolean(b) => Expr::ConstBoolean(!b),
                    _ => Expr::Not(Box::new(rhs)),
                }
            }
            Expr::Ref(rhs) => Expr::Ref(Box::new(rhs.eval_const_inner(st, args))),
            Expr::Neg(rhs) => {
                let rhs = rhs.eval_const_inner(st, args);
                rhs.as_value()
                    .map(|v| v.neg().map(Expr::from).unwrap_or_else(Expr::from))
                    .unwrap_or_else(|| Expr::Neg(Box::new(rhs)))
            }
            Expr::Deref(rhs) => Expr::Deref(Box::new(rhs.eval_const_inner(st, args))),
            Expr::Eq(a, b, t) => try_binop(
                a.eval_const_inner(st, args),
                b.eval_const_inner(st, args),
                |a, b| Ok(Value::Boolean(a.cmp_op(b, Ordering::Equal, false))),
                |a, b| Expr::Eq(a, b, t),
            ),
            Expr::Neq(a, b, t) => try_binop(
                a.eval_const_inner(st, args),
                b.eval_const_inner(st, args),
                |a, b| Ok(Value::Boolean(a.cmp_op(b, Ordering::Equal, true))),
                |a, b| Expr::Neq(a, b, t),
            ),
            Expr::Lt(a, b, t) => try_binop(
                a.eval_const_inner(st, args),
                b.eval_const_inner(st, args),
                |a, b| Ok(Value::Boolean(a.cmp_op(b, Ordering::Less, false))),
                |a, b| Expr::Lt(a, b, t),
            ),
            Expr::Lte(a, b, t) => try_binop(
                a.eval_const_inner(st, args),
                b.eval_const_inner(st, args),
                |a, b| Ok(Value::Boolean(a.cmp_op(b, Ordering::Greater, true))),
                |a, b| Expr::Lte(a, b, t),
            ),
            Expr::Gt(a, b, t) => try_binop(
                a.eval_const_inner(st, args),
                b.eval_const_inner(st, args),
                |a, b| Ok(Value::Boolean(a.cmp_op(b, Ordering::Greater, false))),
                |a, b| Expr::Gt(a, b, t),
            ),
            Expr::Gte(a, b, t) => try_binop(
                a.eval_const_inner(st, args),
                b.eval_const_inner(st, args),
                |a, b| Ok(Value::Boolean(a.cmp_op(b, Ordering::Less, true))),
                |a, b| Expr::Gte(a, b, t),
            ),
            Expr::Array(_) => todo!(),
            Expr::StructConstructor(_) => todo!(),
            Expr::Cast(_, _, _) => todo!(),
            Expr::Block(_) => todo!(),
        }
    }
    fn as_value(&self) -> Option<Value> {
        Some(match self {
            &Expr::ConstBoolean(v) => Value::Boolean(v),
            &Expr::ConstI8(v) => Value::I8(v),
            &Expr::ConstU8(v) => Value::U8(v),
            &Expr::ConstI16(v) => Value::I16(v),
            &Expr::ConstU16(v) => Value::U16(v),
            &Expr::ConstI32(v) => Value::I32(v),
            &Expr::ConstU32(v) => Value::U32(v),
            &Expr::ConstFloat(v) => Value::Float(v),
            &Expr::ConstCompInteger(v) => Value::CompInt(v),
            Expr::ConstString(v) => Value::String(v.clone()),
            Expr::ConstUnit => Value::Unit,
            Expr::ConstNull => Value::Null,
            Expr::Ref(_) => todo!(),
            Expr::Array(_) => todo!(),
            Expr::StructConstructor(_) => todo!(),
            _ => return None,
        })
    }
    fn is_const_zero(&self) -> bool {
        match self {
            Expr::ConstU8(0)
            | Expr::ConstI8(0)
            | Expr::ConstU16(0)
            | Expr::ConstI16(0)
            | Expr::ConstU32(0)
            | Expr::ConstI32(0)
            | Expr::ConstCompInteger(0) => true,
            Expr::ConstFloat(f) => f.abs() < f64::EPSILON,
            _ => false,
        }
    }
    fn is_const_one(&self) -> bool {
        match self {
            Expr::ConstU8(1)
            | Expr::ConstI8(1)
            | Expr::ConstU16(1)
            | Expr::ConstI16(1)
            | Expr::ConstU32(1)
            | Expr::ConstI32(1)
            | Expr::ConstCompInteger(1) => true,
            Expr::ConstFloat(f) => (f - 1.).abs() < f64::EPSILON,
            _ => false,
        }
    }
}
